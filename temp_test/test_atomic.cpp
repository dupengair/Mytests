#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <iostream>#include <thread>#include <atomic>//#define TEST_ATOMAIC#define TEST_SPINLOCK//#define TEST_MEMORDER_DEF//#define TEST_MEMORDER_RLS_ACQ//#define TEST_MEMORDER_RLS_CSM#ifdef TEST_ATOMAIC//std::atomic_int total {0};          // ¶¨ÒåÎªÔ­×ÓÀàĞÍstd::atomic<int> total {0};          // ¶¨ÒåÎªÔ­×ÓÀàĞvoid func(int n) {    printf("start thread %d\n", n);    for(int i = 0; i < 10000; ++i)        total += i;         // ¶ÔÔ­×ÓÀàĞÍµÄ·ÃÎÊ×ÔÈ»»¥³â}int main(){    int i;    i = getuid();    if(i==0)        printf("The current user is root\n");    else        printf("The current user is not root\n");    printf(" >>>>>>>>>>>>>test start<<<<<<<<<<<<<<\n");    std::thread t1(func, 1);    std::thread t2(func, 2);        t1.join();    t2.join();        printf(" >>>>>>>>>>>>>test over<<<<<<<<<<<<<<\n");    return 0;}#elif defined(TEST_SPINLOCK)std::atomic_flag lock = ATOMIC_FLAG_INIT;void f(int n) {    printf("start thread %d\n", n);    printf("wait for flag in thread: %d\n", n);    while(lock.test_and_set(std::memory_order_acquire))         printf("spinning\n");   // ×ÔĞı    printf("out of spinlock\n");// do something} void g(int n) {    printf("start thread %d\n", n);    sleep(1);    printf("set flag in thread: %d\n", n);    lock.clear();}int main() {    lock.test_and_set();    std::thread t1(f, 1);    std::thread t2(g, 2);    t1.join();    usleep(100);    t2.join();}#elif defined(TEST_MEMORDER_DEF)std::atomic<int> a {0};std::atomic<int> b {0};int Set(int n) {    printf("start thread %d\n", n);    a = 1;			// Á½ÌõÓï¾ä²»´æÔÚÖ´ĞĞË³ĞòÏà¹ØĞÔ£¬¿ÉÄÜË³Ğò²»Ò»ÖÂ    b = 2;			// ±àÒëÆ÷ÈÏÎªÁ½ÌõÓï¾ä²»´æÔÚË³Ğò¹ØÏµÊ±£¬¿É´òÂÒË³ĞòÖ´ĞĞ}int Print(int n) {    printf("start thread %d\n", n);    while(b != 2);		// ÓÉÓÚ±àÒëÆ÷ÂÒĞòÖ´ĞĞ£¬ÅĞ¶ÏÌõ¼ş³ÉÁ¢Ê±a²»Ò»¶¨Îª1    std::cout << "a = " << a << std::endl;} int main() {    std::thread t1(Set, 1);    std::thread t2(Print, 2);		// Êä³ö½á¹ûÈ¡¾öÓÚSetÖĞÓï¾äµÄÖ´ĞĞË³Ğò    t1.join();    t2.join();}#elif defined(TEST_MEMORDER_RLS_ACQ)std::atomic<int> a {0};std::atomic<int> b {0};int Set(int n) {    printf("start thread %d\n", n);    a.store(1, std::memory_order_relaxed);			    b.store(2, std::memory_order_release);	// ËùÓĞµÄÔ­×ÓĞ´²Ù×÷Ö´ĞĞÍê³ÉºóÖ´ĞĞ±¾²Ù×÷£¬¼´a.storeÖ´ĞĞÍêºóÖ´ĞĞ±¾²Ù×÷}int Print(int n) {    printf("start thread %d\n", n);    while(b.load(std::memory_order_acquire) != 2);   // ±¾Ô­×Ó²Ù×÷Ö´ĞĞÍêºó²ÅÄÜÖ´ĞĞÔ­×Ó¶Á²Ù×÷£¬¼´a.loadÒªÔÚwhileºóÖ´ĞĞ    std::cout << "a = " << a.load(std::memory_order_relaxed) << std::endl;		// Êä³öÒ»¶¨Îªa = 1	} int main() {    std::thread t1(Set, 1);    std::thread t2(Print, 2);		// Êä³ö½á¹ûÈ¡¾öÓÚSetÖĞÓï¾äµÄÖ´ĞĞË³Ğò    t1.join();    t2.join();}#elif defined(TEST_MEMORDER_RLS_CSM)std::atomic<int> a {0};std::atomic<int> b {0};int Set(int n) {    printf("start thread %d\n", n);    a.store(1, std::memory_order_relaxed);			    b.store(2, std::memory_order_release);	// ËùÓĞµÄÔ­×ÓĞ´²Ù×÷Ö´ĞĞÍê³ÉºóÖ´ĞĞ±¾²Ù×÷£¬¼´a.storeÖ´ĞĞÍêºóÖ´ĞĞ±¾²Ù×÷}int Print(int n) {    printf("start thread %d\n", n);    while(b.load(std::memory_order_consume) != 2);   // ±¾Ô­×Ó²Ù×÷Ö´ĞĞÍêºó²ÅÄÜÖ´ĞĞbÀàĞÍµÄÔ­×Ó¶Á²Ù×÷£¬¼´b.loadÒªÔÚwhileºóÖ´ĞĞ£¬µ«²»Ô¼¶¨aµÄÖ´ĞĞË³Ğò    std::cout << "a = " << a.load(std::memory_order_relaxed) << std::endl;		// Êä³öÒ»¶¨Îªa = 1	    std::cout << "b = " << b.load(std::memory_order_relaxed) << std::endl;		//¿ÉÄÜÔÚwhileÇ°Ö´ĞĞ} int main() {    std::thread t1(Set, 1);    std::thread t2(Print, 2);		// Êä³ö½á¹ûÒ»¶¨ÊÇb = 2£¬µ«²»Ò»¶¨a = 1     t1.join();    t2.join();}        #endif